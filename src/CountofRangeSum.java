class CountofRangeSum {    public int countRangeSum(int[] nums, int lower, int upper) {        BST<Long> bst = new BST<>();        long sum = 0;        int cnt = 0;        bst.put(sum);        for (int num : nums) {            sum += num;            cnt += (bst.rank(sum - lower + 1) - bst.rank(sum - upper));            bst.put(sum);        }        return cnt;    }    class BST<Key extends Comparable<Key>> {        private Node root;        private final boolean RED = true;        private final boolean BLACK = false;        public int size(Node x) {            return x == null ? 0 : x.n;        }        public boolean isRed(Node x) {            return x == null ? BLACK : x.color;        }        public void put(Key key) {            root = put(root, key);            root.color = BLACK;        }        public Node put(Node x, Key key) {            if (x == null) return new Node(key, RED);            int cmp = key.compareTo(x.key);            if (cmp < 0) x.left = put(x.left, key);            else if (cmp > 0) x.right = put(x.right, key);            else x.val += 1;  //在当前的节点的val上加1，最后一句更新n的时候会算上            x.n = size(x.left) + size(x.right) + x.val;            if (isRed(x.left) && isRed(x.left.left)) x = rotateRight(x);            if (isRed(x.right) && !isRed(x.left)) x = rotateLeft(x);            if (isRed(x.left) && isRed(x.right)) flipColor(x);            return x;        }        public void flipColor(Node h) {            h.left.color = BLACK;            h.right.color = BLACK;            h.color = RED;        }        public Node rotateLeft(Node h) {            Node x = h.right;            h.right = x.left;            x.left = h;            x.color = h.color;            h.color = RED;            x.n = h.n;            h.n = h.val + size(h.left) + size(h.right);            return x;        }        public Node rotateRight(Node h) {            Node x = h.left;            h.left = x.right;            x.right = h;            x.color = h.color;            h.color = RED;            x.n = h.n;            h.n = h.val + size(h.left) + size(h.right);            return x;        }        // Number of keys in the subtree less than key.        public int rank(Key key) {            return rank(key, root);        }        public int rank(Key key, Node x) {            if (x == null) return 0;            int cmp = key.compareTo(x.key);            if (cmp < 0) return rank(key, x.left);            else if (cmp > 0) return rank(key, x.right) + x.val + size(x.left);            else return size(x.left);        }        class Node {            private Key key;            private int val;            private Node left, right;            private int n; // # nodes rooted at the node            private boolean color;            Node(Key key, boolean col) {                this.key = key;                this.val = 1;                this.n = 1;                this.color = col;            }        }    }}